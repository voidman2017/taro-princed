# 页面page对应运行时

**以page/index/index 为例，运行时的 js：**

```javascript
var inst = Page((0,_tarojs_runtime__WEBPACK_IMPORTED_MODULE_0__.createPageConfig)(_packages_taro_loader_lib_raw_js_index_vue__WEBPACK_IMPORTED_MODULE_1__["default"], 'pages/index/index', {root:{cn:[]}}, config || {}))
```

![1737357176044](image/运行时/1737357176044.png)

我们简化一下：

![](image/运行时/1737357369293.png)

**其中**

* `_tarojs_runtime__WEBPACK_IMPORTED_MODULE_0__.createPageConfig` 即 taro/runtime 中  `createPageConfig`

**接受参数：**

* **component:** `_packages_taro_loader_lib_raw_js_index_vue__WEBPACK_IMPORTED_MODULE_1__['default']`

  ![](image/运行时/1737357440270.png)
* **pageName：`'pages/index/index'`**
* **data：** `{root:{cn:[]}}`
* **pageConfig:** `{}`

`createPageConfig` 方法定义在 packages/taro-runtime/src/dsl/common.ts


![1737357504101](image/运行时/1737357504101.png)

**通过createPageConfig生成config，最终调用 Page 构造器生成页面**：

![](image/运行时/1737357824523.png)

**页面代码如下：**

```vue
<template>
  <view class="index">
    <text>{{ msg }}</text>
    <button @tap="clickHandler"> click </button>
  </view>
</template>

<script>
import './index.scss'

export default {
  data () {
    return {
      msg: 'Hello world!'
    }
  },
  methods:{
    clickHandler(){
      this.msg += '!'
    }
  }
}
</script>
```

**修改生成的 index.wxml**

![](image/运行时/1737357021006.png)

**可以看到：**

![](image/运行时/1737357051173.png)

**即渲染的核心就是通过root定义内容结合模板进行渲染**

**那么问题是** : root是如何生成的？？？？？？

**目前初步看是 packages/taro-runtime/src/dom/root.ts 进行root设置的 ；（开发模式下可以将 packages/taro-runtime/src/options.ts 中 debug 开启，查看设置的root值）**

![1737357903085](image/运行时/1737357903085.png)

`normalUpdate`：

![1737357933380](image/运行时/1737357933380.png)

![](https://cdn.nlark.com/yuque/0/2022/png/233312/1648633508729-a8d203ea-3d27-4f49-a359-39ad8f5998ce.png)


**data['root.cn[0]'] 是调用 ['root.cn.[0]', 'root.cn[0]'] 对应的函数生成的。**

![1737363993351](image/运行时/1737363993351.png)

![1737364043150](image/运行时/1737364043150.png)

这里执行会使 data['root.cn'] 挂载一个 `rerenderChildNodes` 的方法

![1737364098435](image/运行时/1737364098435.png)

该方法位于： packages/taro-runtime/src/dom/node.ts 中

![1737364152711](image/运行时/1737364152711.png)

那么

![1737364609323](image/运行时/1737364609323.png)


* **data：**

![1737358143688](image/运行时/1737358143688.png)

* **resetPaths：**

![](https://cdn.nlark.com/yuque/0/2022/png/233312/1648696405497-0652d886-e6b3-4759-8a8d-69e7a9a1924a.png)

![img](https://cdn.nlark.com/yuque/0/2022/png/233312/1648696523661-4144416e-4f29-4991-8e78-adbfd741b5e8.png)

* **【112-115】将 root.cn.[0] 转换成对应的 fn 执行的结果**

# ['root.cn.[0]', 'root.cn[0]'] 对应的函数挂载：

**packages/taro-runtime/src/dom/node.ts**

![1737358210556](image/运行时/1737358210556.png)

![1737358278518](image/运行时/1737358278518.png)

**packages/taro-mini-runner/src/webpack/build.conf.ts**

![](image/运行时/1737358310812.png)

**可以看到这里有使用 plugin.provierPlugin 定义了 document、window、Element。**

**造成的结果，当基于 vue 实现 vnode => dom的过程中调用 document.createElement 之类的api时，实际执行的是 taro中定义的运行时的document的api。**

![](image/运行时/1737358470251.png)


![1737359769749](image/运行时/1737359769749.png)

![](https://cdn.nlark.com/yuque/0/2022/jpeg/233312/1648869422216-13aebd7d-b5c0-4485-a34d-a9f578a820b8.jpeg)

# wx["webpackJsonp"]

**wx["webpackJsonp"] 是 taro 挂载在 wx 上的新增属性。**

![](https://cdn.nlark.com/yuque/0/2022/png/233312/1648547673310-d6430a55-d8ef-489a-b584-c900b5a7d350.png)

![](https://cdn.nlark.com/yuque/0/2022/png/233312/1648547550495-7bc1679e-40c8-4e1b-acdb-42f894d76947.png)

**可以看到 webpackJsonp 是一个二维数组。数组每一个项都是一个数组。以 app.js 为例：**

**第一个参数： 数组 ['app']**

**第二个参数：对象 **

**第三个参数：数组 [["./src/app.ts","runtime","vendors","common"]]**
